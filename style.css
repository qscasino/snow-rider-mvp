import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

// =========================
// Storage / casino rules
// =========================
const STORAGE = {
  TRIES_LEFT: "sr_level_triesLeft",   // number
  BEST_PROGRESS: "sr_level_bestPct",  // number 0..100
  RESULT: "sr_level_lastResult",      // "200" | "100"
};

const MAX_TRIES = 3;
const PRIZE_WIN = "Bono del 200% ‚úÖ (Meta alcanzada)";
const PRIZE_LOSE = "Bono del 100% üéÅ (Premio consuelo)";

// =========================
// UI
// =========================
const el = {
  preloader: document.getElementById("preloader"),
  barFill: document.getElementById("barFill"),
  barText: document.getElementById("barText"),

  progressText: document.getElementById("progressText"),
  triesText: document.getElementById("triesText"),
  bestText: document.getElementById("bestText"),

  soundBtn: document.getElementById("soundBtn"),

  arrows: document.getElementById("arrows"),
  leftBtn: document.getElementById("leftBtn"),
  rightBtn: document.getElementById("rightBtn"),

  startOverlay: document.getElementById("startOverlay"),
  playBtn: document.getElementById("playBtn"),
  howBtn: document.getElementById("howBtn"),
  triesWarn: document.getElementById("triesWarn"),

  howOverlay: document.getElementById("howOverlay"),
  backBtn: document.getElementById("backBtn"),

  failOverlay: document.getElementById("failOverlay"),
  triesLeftText: document.getElementById("triesLeftText"),
  retryBtn: document.getElementById("retryBtn"),
  menuBtn: document.getElementById("menuBtn"),

  resultOverlay: document.getElementById("resultOverlay"),
  resultTitle: document.getElementById("resultTitle"),
  resultText: document.getElementById("resultText"),
  claimBtn: document.getElementById("claimBtn"),
  closeBtn: document.getElementById("closeBtn"),
};

let soundEnabled = true;
el.soundBtn.addEventListener("click", () => {
  soundEnabled = !soundEnabled;
  el.soundBtn.textContent = soundEnabled ? "üîä" : "üîá";
  el.soundBtn.classList.toggle("muted", !soundEnabled);
});

// =========================
// Helpers
// =========================
const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
const lerp = (a, b, t) => a + (b - a) * t;

function getTriesLeft() {
  const v = localStorage.getItem(STORAGE.TRIES_LEFT);
  if (v === null) return MAX_TRIES;
  return clamp(Number(v), 0, MAX_TRIES);
}
function setTriesLeft(v) {
  localStorage.setItem(STORAGE.TRIES_LEFT, String(clamp(v, 0, MAX_TRIES)));
}
function getBestPct() {
  return clamp(Number(localStorage.getItem(STORAGE.BEST_PROGRESS) || 0), 0, 100);
}
function setBestPct(v) {
  const cur = getBestPct();
  if (v > cur) localStorage.setItem(STORAGE.BEST_PROGRESS, String(v));
}
function resetTries() {
  setTriesLeft(MAX_TRIES);
}

// =========================
// Game constants
// =========================
const lanes = [-3.2, 0, 3.2];
const LEVEL_LENGTH = 220;           // ‚Äúmetros‚Äù del nivel
const START_Z = 10;                 // inicio cercano a c√°mara
const FINISH_Z = -LEVEL_LENGTH;     // meta

// =========================
// Three.js core
// =========================
let scene, camera, renderer, clock;
let running = false;
let finished = false;
let crashed = false;

const state = {
  lane: 0,
  laneX: 0,
  speed: 18,     // velocidad constante (pod√©s ajustar)
  z: START_Z,    // avance del jugador: baja hacia negativo
};

let sled;
let finishGate;

// Obst√°culos colocados a mano (predise√±ados)
const obstacles = [];
// Each: { type: "tree"|"snowman"|"rock", lane: -1|0|1, z: -number, mesh }
const LEVEL_LAYOUT = buildLevelLayout();

// Ground
let ground1, ground2;
let snowPoints;

// =========================
// Boot
// =========================
startPreloader().then(() => {
  init3D();
  initUI();
  animate();
  hidePreloader();
  syncHud();
});

function syncHud() {
  el.triesText.textContent = String(getTriesLeft());
  el.bestText.textContent = `${Math.floor(getBestPct())}%`;

  const tries = getTriesLeft();
  if (tries <= 0) {
    el.playBtn.disabled = true;
    el.playBtn.style.opacity = "0.6";
    el.triesWarn.style.display = "block";
  } else {
    el.playBtn.disabled = false;
    el.playBtn.style.opacity = "1";
    el.triesWarn.style.display = "none";
  }
}

async function startPreloader() {
  let p = 0;
  return new Promise((resolve) => {
    const it = setInterval(() => {
      p += Math.random() * 18 + 8;
      if (p >= 100) {
        p = 100;
        clearInterval(it);
        resolve();
      }
      el.barFill.style.width = `${p}%`;
      el.barText.textContent = `${Math.floor(p)}%`;
    }, 140);
  });
}

function hidePreloader() {
  el.preloader.style.transition = "opacity .5s ease, visibility .5s ease";
  el.preloader.style.opacity = "0";
  el.preloader.style.visibility = "hidden";
  el.preloader.style.pointerEvents = "none";
}

// =========================
// UI
// =========================
function initUI() {
  el.playBtn.addEventListener("click", () => {
    if (getTriesLeft() <= 0) {
      // ya no hay intentos: mostrar consuelo directo
      showResult(false, true);
      return;
    }
    startRun();
  });

  el.howBtn.addEventListener("click", () => {
    el.startOverlay.classList.add("hidden");
    el.howOverlay.classList.remove("hidden");
  });

  el.backBtn.addEventListener("click", () => {
    el.howOverlay.classList.add("hidden");
    el.startOverlay.classList.remove("hidden");
  });

  el.retryBtn.addEventListener("click", () => {
    if (getTriesLeft() <= 0) {
      showResult(false, true);
      return;
    }
    startRun();
  });

  el.menuBtn.addEventListener("click", () => {
    showMenu();
  });

  el.closeBtn.addEventListener("click", () => {
    el.resultOverlay.classList.add("hidden");
  });

  el.claimBtn.addEventListener("click", () => {
    // Pod√©s redirigir a WhatsApp / link
    // window.location.href = "https://wa.me/XXXXXXXXXX?text=Gan√©%20el%20bono...";
    el.resultOverlay.classList.add("hidden");
    showMenu();
  });

  // Mobile arrows
  el.leftBtn.addEventListener("pointerdown", () => { if (running) setLane(state.lane - 1); });
  el.rightBtn.addEventListener("pointerdown", () => { if (running) setLane(state.lane + 1); });

  // Keyboard
  window.addEventListener("keydown", (e) => {
    if (!running) return;
    if (e.key === "ArrowLeft") setLane(state.lane - 1);
    if (e.key === "ArrowRight") setLane(state.lane + 1);
  });

  // Swipe
  setupTouchControls();

  // Tap to start (nice on mobile)
  window.addEventListener("pointerdown", () => {
    if (!running && !finished && !crashed && !el.startOverlay.classList.contains("hidden")) return;
  }, { passive: true });
}

function showMenu() {
  el.failOverlay.classList.add("hidden");
  el.resultOverlay.classList.add("hidden");
  el.howOverlay.classList.add("hidden");
  el.startOverlay.classList.remove("hidden");
  syncHud();
}

function showFail() {
  el.triesLeftText.textContent = String(getTriesLeft());
  el.failOverlay.classList.remove("hidden");
}

function showResult(won, outOfTries = false) {
  el.failOverlay.classList.add("hidden");
  el.startOverlay.classList.add("hidden");

  if (won) {
    el.resultTitle.textContent = "üèÅ ¬°Llegaste a la meta!";
    el.resultText.textContent = PRIZE_WIN;
    localStorage.setItem(STORAGE.RESULT, "200");
  } else {
    el.resultTitle.textContent = outOfTries ? "üéÅ Premio consuelo" : "üéÅ Resultado";
    el.resultText.textContent = PRIZE_LOSE;
    localStorage.setItem(STORAGE.RESULT, "100");
  }

  el.resultOverlay.classList.remove("hidden");
  syncHud();
}

// =========================
// Touch controls (swipe)
// =========================
function setupTouchControls() {
  let startX = 0, startY = 0, tracking = false;

  window.addEventListener("touchstart", (e) => {
    if (!running) return;
    const t = e.touches && e.touches[0];
    if (!t) return;
    tracking = true;
    startX = t.clientX;
    startY = t.clientY;
  }, { passive: true });

  window.addEventListener("touchend", (e) => {
    if (!running || !tracking) return;
    tracking = false;
    const t = e.changedTouches && e.changedTouches[0];
    if (!t) return;

    const dx = t.clientX - startX;
    const dy = t.clientY - startY;

    if (Math.abs(dx) > 28 && Math.abs(dx) > Math.abs(dy)) {
      if (dx > 0) setLane(state.lane + 1);
      else setLane(state.lane - 1);
    }
  }, { passive: true });
}

function setLane(l) {
  state.lane = clamp(l, -1, 1);
}

// =========================
// 3D init
// =========================
function init3D() {
  scene = new THREE.Scene();
  scene.fog = new THREE.Fog(0x061a24, 18, 120);

  camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 260);
  camera.position.set(0, 6.6, 12.5);
  camera.lookAt(0, 2.2, -10);

  renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setClearColor(0x061a24);
  document.body.appendChild(renderer.domElement);

  const hemi = new THREE.HemisphereLight(0xffffff, 0x0b2c3b, 0.95);
  scene.add(hemi);

  const dir = new THREE.DirectionalLight(0xffffff, 1.15);
  dir.position.set(8, 14, 8);
  scene.add(dir);

  // Ground tiles (scroll illusion)
  const groundMat = new THREE.MeshStandardMaterial({ color: 0xeaf7ff, roughness: 0.92 });
  const groundGeo = new THREE.PlaneGeometry(22, 90);

  ground1 = new THREE.Mesh(groundGeo, groundMat);
  ground1.rotation.x = -Math.PI / 2;
  ground1.position.z = -30;
  scene.add(ground1);

  ground2 = new THREE.Mesh(groundGeo, groundMat);
  ground2.rotation.x = -Math.PI / 2;
  ground2.position.z = -120;
  scene.add(ground2);

  // Lane separators (subtle)
  const lineMat = new THREE.MeshStandardMaterial({ color: 0xcfefff, transparent: true, opacity: 0.20 });
  const lineGeo = new THREE.BoxGeometry(0.06, 0.02, 140);
  [-1.6, 1.6].forEach((x) => {
    const ln = new THREE.Mesh(lineGeo, lineMat);
    ln.position.set(x, 0.02, -80);
    scene.add(ln);
  });

  // Sled - ‚Äúlook‚Äù parecido (colores tipo 4 tablones)
  sled = buildSledLike();
  sled.position.set(0, 0.34, 6);
  scene.add(sled);

  // Finish gate
  finishGate = buildFinishGate();
  finishGate.position.set(0, 0, FINISH_Z);
  scene.add(finishGate);

  // Obstacles from layout
  for (const item of LEVEL_LAYOUT) {
    const m = buildObstacleMesh(item.type);
    m.position.set(lanes[item.lane + 1], 0, item.z);
    m.userData.type = item.type;
    m.userData.radius = item.type === "tree" ? 1.0 : item.type === "snowman" ? 0.85 : 0.9;
    scene.add(m);
    obstacles.push({ ...item, mesh: m });
  }

  // snow particles
  snowPoints = addSnowParticles();

  clock = new THREE.Clock();
  window.addEventListener("resize", onResize);
}

function buildSledLike() {
  const group = new THREE.Group();

  const railMat = new THREE.MeshStandardMaterial({ color: 0x1f1f1f, roughness: 0.55 });
  const plankMats = [
    new THREE.MeshStandardMaterial({ color: 0x2d6cdf, roughness: 0.55 }), // blue
    new THREE.MeshStandardMaterial({ color: 0xe6c54a, roughness: 0.55 }), // yellow
    new THREE.MeshStandardMaterial({ color: 0xc6453b, roughness: 0.55 }), // red
    new THREE.MeshStandardMaterial({ color: 0x2f9b4b, roughness: 0.55 }), // green
  ];

  // rails
  const railGeo = new THREE.BoxGeometry(0.22, 0.18, 2.6);
  const railL = new THREE.Mesh(railGeo, railMat);
  railL.position.set(-1.15, 0.10, 0);
  const railR = new THREE.Mesh(railGeo, railMat);
  railR.position.set( 1.15, 0.10, 0);
  group.add(railL, railR);

  // 4 planks
  const plankGeo = new THREE.BoxGeometry(0.48, 0.12, 2.2);
  const xs = [-0.72, -0.24, 0.24, 0.72];
  xs.forEach((x, i) => {
    const p = new THREE.Mesh(plankGeo, plankMats[i]);
    p.position.set(x, 0.22, 0.05);
    group.add(p);

    // ‚Äútornillitos‚Äù
    const screwMat = new THREE.MeshStandardMaterial({ color: 0x9fb2bd, roughness: 0.9 });
    const screwGeo = new THREE.BoxGeometry(0.10, 0.05, 0.14);
    const s1 = new THREE.Mesh(screwGeo, screwMat);
    s1.position.set(x, 0.30, -0.55);
    const s2 = new THREE.Mesh(screwGeo, screwMat);
    s2.position.set(x, 0.30, 0.65);
    group.add(s1, s2);
  });

  // handle bar
  const handleMat = new THREE.MeshStandardMaterial({ color: 0x202020, roughness: 0.45 });
  const handle = new THREE.Mesh(new THREE.TorusGeometry(1.35, 0.09, 12, 28), handleMat);
  handle.rotation.x = Math.PI / 2;
  handle.position.set(0, 0.55, 1.00);
  group.add(handle);

  return group;
}

function buildFinishGate() {
  const g = new THREE.Group();

  const postMat = new THREE.MeshStandardMaterial({ color: 0x2a2a2a, roughness: 0.7 });
  const bannerMat = new THREE.MeshStandardMaterial({ color: 0xffd700, roughness: 0.45, emissive: 0x221a00, emissiveIntensity: 0.7 });

  const postGeo = new THREE.BoxGeometry(0.25, 3.2, 0.25);
  const left = new THREE.Mesh(postGeo, postMat);
  left.position.set(-4.3, 1.6, 0);
  const right = new THREE.Mesh(postGeo, postMat);
  right.position.set(4.3, 1.6, 0);

  const banner = new THREE.Mesh(new THREE.BoxGeometry(9.2, 0.55, 0.2), bannerMat);
  banner.position.set(0, 3.0, 0);

  g.add(left, right, banner);

  // small flags
  const flagMat = new THREE.MeshStandardMaterial({ color: 0xc41e3a, roughness: 0.55 });
  const flagGeo = new THREE.BoxGeometry(0.15, 0.9, 0.15);
  for (let i = -4; i <= 4; i += 2) {
    const f = new THREE.Mesh(flagGeo, flagMat);
    f.position.set(i, 3.7, 0);
    g.add(f);
  }
  return g;
}

function addSnowParticles() {
  const geo = new THREE.BufferGeometry();
  const count = 700;
  const positions = new Float32Array(count * 3);

  for (let i = 0; i < count; i++) {
    positions[i * 3 + 0] = (Math.random() - 0.5) * 26;
    positions[i * 3 + 1] = Math.random() * 12 + 2;
    positions[i * 3 + 2] = -Math.random() * (LEVEL_LENGTH + 140);
  }

  geo.setAttribute("position", new THREE.BufferAttribute(positions, 3));
  const mat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.09, transparent: true, opacity: 0.7 });
  const pts = new THREE.Points(geo, mat);
  scene.add(pts);
  return pts;
}

// =========================
// Level layout builder (predise√±ado)
// =========================
function buildLevelLayout() {
  // Dise√±amos una pista con ‚Äúzonas‚Äù y patrones simples
  // z va hacia negativo (m√°s lejos = m√°s negativo)
  const items = [];

  const add = (type, lane, z) => items.push({ type, lane, z });

  // Zona 1 (arranque) - f√°cil
  add("tree", -1, -25);
  add("snowman",  1, -35);
  add("rock",     0, -45);

  // Zona 2 - zigzag
  add("tree", -1, -60);
  add("tree",  1, -70);
  add("snowman", -1, -80);
  add("snowman",  1, -90);

  // Zona 3 - doble presi√≥n
  add("rock", -1, -105);
  add("rock",  1, -105);
  add("tree",  0, -120);

  // Zona 4 - patr√≥n tipo ‚Äúslalom‚Äù
  const slalomZ = [-135,-145,-155,-165,-175];
  const slalomLane = [-1,0,1,0,-1];
  for (let i=0;i<slalomZ.length;i++){
    add("snowman", slalomLane[i], slalomZ[i]);
  }

  // Zona 5 - final
  add("tree",  1, -190);
  add("rock",  0, -200);
  add("tree", -1, -208);

  return items;
}

function buildObstacleMesh(type) {
  if (type === "tree") return buildTree();
  if (type === "snowman") return buildSnowman();
  return buildRock();
}

function buildTree() {
  const g = new THREE.Group();

  const trunkMat = new THREE.MeshStandardMaterial({ color: 0x5b3a1e, roughness: 0.85 });
  const leafMat  = new THREE.MeshStandardMaterial({ color: 0x2c7d4a, roughness: 0.75 });

  const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.22, 0.28, 1.2, 8), trunkMat);
  trunk.position.y = 0.6;

  const cone1 = new THREE.Mesh(new THREE.ConeGeometry(0.95, 1.4, 10), leafMat);
  cone1.position.y = 1.55;
  const cone2 = new THREE.Mesh(new THREE.ConeGeometry(0.75, 1.2, 10), leafMat);
  cone2.position.y = 2.05;

  g.add(trunk, cone1, cone2);
  g.position.y = 0;
  return g;
}

function buildSnowman() {
  const g = new THREE.Group();
  const whiteMat = new THREE.MeshStandardMaterial({ color: 0xf1fbff, roughness: 0.9 });
  const coalMat  = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.8 });
  const noseMat  = new THREE.MeshStandardMaterial({ color: 0xff8a2a, roughness: 0.7 });

  const b1 = new THREE.Mesh(new THREE.SphereGeometry(0.55, 12, 12), whiteMat);
  b1.position.y = 0.55;
  const b2 = new THREE.Mesh(new THREE.SphereGeometry(0.40, 12, 12), whiteMat);
  b2.position.y = 1.25;
  const head = new THREE.Mesh(new THREE.SphereGeometry(0.30, 12, 12), whiteMat);
  head.position.y = 1.78;

  const eye1 = new THREE.Mesh(new THREE.SphereGeometry(0.05, 10, 10), coalMat);
  eye1.position.set(-0.09, 1.84, 0.22);
  const eye2 = eye1.clone();
  eye2.position.x = 0.09;

  const nose = new THREE.Mesh(new THREE.ConeGeometry(0.05, 0.28, 10), noseMat);
  nose.position.set(0, 1.78, 0.30);
  nose.rotation.x = Math.PI / 2;

  g.add(b1, b2, head, eye1, eye2, nose);
  return g;
}

function buildRock() {
  const geo = new THREE.DodecahedronGeometry(0.95, 0);
  const mat = new THREE.MeshStandardMaterial({ color: 0x8aa0aa, roughness: 0.95 });
  return new THREE.Mesh(geo, mat);
}

// =========================
// Run control
// =========================
function resetRun() {
  running = false;
  finished = false;
  crashed = false;

  state.lane = 0;
  state.laneX = 0;
  state.z = START_Z;

  sled.position.set(0, 0.34, 6);
  sled.rotation.set(0, 0, 0);

  // obstacles stay fixed; no need reset
  updateProgressHud();
}

function startRun() {
  el.startOverlay.classList.add("hidden");
  el.howOverlay.classList.add("hidden");
  el.failOverlay.classList.add("hidden");
  el.resultOverlay.classList.add("hidden");

  resetRun();
  running = true;
}

function crash() {
  if (!running) return;
  running = false;
  crashed = true;

  // spend a try
  const t = getTriesLeft();
  const next = Math.max(0, t - 1);
  setTriesLeft(next);
  syncHud();

  if (next <= 0) {
    // out of tries -> show consuelo
    showResult(false, true);
  } else {
    showFail();
  }
}

function win() {
  if (!running) return;
  running = false;
  finished = true;

  // reward: 200%
  showResult(true, false);

  // (opcional) si quer√©s resetear intentos al ganar:
  // resetTries(); syncHud();
}

// =========================
// Loop
// =========================
function animate() {
  requestAnimationFrame(animate);
  const dt = clock.getDelta();

  // camera follow lane a bit
  camera.position.x = lerp(camera.position.x, state.laneX * 0.20, 0.06);

  // snow particles drift
  if (snowPoints) {
    const pos = snowPoints.geometry.attributes.position;
    for (let i = 0; i < pos.count; i++) {
      pos.array[i * 3 + 2] += dt * 7.5; // falling effect
      if (pos.array[i * 3 + 2] > 12) pos.array[i * 3 + 2] = -LEVEL_LENGTH - 140;
    }
    pos.needsUpdate = true;
  }

  if (running) updateGame(dt);
  renderer.render(scene, camera);
}

function updateGame(dt) {
  // lane smoothing
  const targetX = lanes[state.lane + 1];
  state.laneX = lerp(state.laneX, targetX, 0.16);

  sled.position.x = state.laneX;
  sled.rotation.z = lerp(sled.rotation.z, -state.lane * 0.09, 0.12);

  // advance along Z (player goes ‚Äúinto the level‚Äù)
  state.z -= state.speed * dt;

  // scroll ground illusion
  const vz = state.speed * dt;
  ground1.position.z += vz;
  ground2.position.z += vz;
  if (ground1.position.z > 40) ground1.position.z = -120;
  if (ground2.position.z > 40) ground2.position.z = -120;

  // progress
  updateProgressHud();

  // collision check
  for (const o of obstacles) {
    // obstacles at o.z fixed in world
    const ox = o.mesh.position.x;
    const oz = o.mesh.position.z;

    // player ‚Äúcurrent world z‚Äù is state.z but camera is fixed; easiest trick:
    // we compare relative distance by shifting player reference onto level:
    const playerZ = state.z; // level coordinate
    const dz = oz - playerZ;

    // only check near player
    if (dz > -8 && dz < 8) {
      const dx = ox - sled.position.x;
      const r = o.mesh.userData.radius || 0.9;
      if ((dx*dx + dz*dz) <= (r + 0.85) * (r + 0.85)) {
        crash();
        return;
      }
    }
  }

  // finish check: when player passes finish z
  if (state.z <= FINISH_Z + 2) {
    win();
  }
}

function updateProgressHud() {
  const traveled = START_Z - state.z; // how much we advanced
  const pct = clamp((traveled / (START_Z - FINISH_Z)) * 100, 0, 100);
  el.progressText.textContent = `${Math.floor(pct)}%`;

  setBestPct(Math.floor(pct));
  el.bestText.textContent = `${Math.floor(getBestPct())}%`;
}

// =========================
// Resize
// =========================
function onResize() {
  if (!renderer || !camera) return;
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}
